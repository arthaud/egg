option auto = true;
option k = 2;
option version = 5.2.8;

inh table : TDS for
    LACTION, INSTS, INST, INST2, AFF, ELSIF, CASE, CASES, VAR,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR,
    APP, ARGS, ARGSX, EARGS, EXCEPTION;
inh reg : REGLE for
    LACTION;
inh avis : IVisiteurAction for
    LACTION, INSTS, INST, AFF, ELSIF, CASE, CASES,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR,
    ARGS, ARGSX, EARGS, EXCEPTION, INST2, APP;
inh act : LACT for
    LACTION, INSTS, INST, AFF, ELSIF, CASE, CASES, VAR,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR,
    ARGS, ARGSX, EARGS, EXCEPTION, INST2, APP;
inh tds_act : TDS_ACTION for
    INSTS, INST, AFF, ELSIF, CASE, CASES, VAR,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR,
    ARGS, ARGSX, EARGS , EXCEPTION, INST2, APP;
syn nom : STRING for
    CASE, OPBOOL, OPCOMP, OPADD, OPMUL;
syn entree : ENTREE for
    VAR;
inh hentree : ENTREE for
    INST2, AFF, CASE, CASES;
syn code : STRING for
    LACTION, INSTS, INST, INST2, AFF, ELSIF, CASE, CASES,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR,
    APP, EXCEPTION;
inh hcode : STRING for
    EXPRREL, RELMEXPR, MEXPRTERME, TERMEFACTEUR, APP;
syn args : Vector<STRING> for
    ARGS, EARGS, ARGSX;
inh hargs : Vector<STRING> for
    ARGS, EARGS, ARGSX;
syn type : IType for
    TYPE, CASE, APP,
    EXPR, EXPRREL, REL, RELMEXPR, MEXPR, MEXPRTERME, TERME, TERMEFACTEUR, FACTEUR;
inh htype : IType for
    EXPRREL, RELMEXPR, MEXPRTERME, TERMEFACTEUR, APP;
syn types : Vector<IType> for
    ARGS, EARGS, ARGSX;
inh htypes : Vector<IType> for
    ARGS, EARGS, ARGSX;
inh res : Resolveur for
    TYPE, TGEN, XTYPE;
syn pars : Vector<IType> for
    TGEN, XTYPE;

syn offset : INTEGER for LACTION;
syn length : INTEGER for LACTION;


space      separateur       is    "[\r\n\t ]+" ;
comment    commentaires     is    "\-\-[^\n]*\n" ;
comment    big              is    "\-\*([^\*]|(\*+[^\*\-]))*\*+\-" ;
sugar      t_point          is    "\."              aka $.$ ;
sugar      t_chapeau        is    "\^"              aka $^$ ;
sugar      t_virgule        is    "\,"              aka $,$ ;
sugar      t_pointvirgule   is    ";"               aka $;$ ;
sugar      t_deuxpoints     is    ":"               aka $:$ ;
sugar      t_affectation    is    "(:=)"            aka $:=$ ;
sugar      t_inf_egal       is    "\<="             aka $<=$ ;
sugar      t_inf            is    "\<"              aka $<$ ;
sugar      t_sup_egal       is    "\>="             aka $>=$ ;
sugar      t_sup            is    "\>"              aka $>$ ;
sugar      t_paro           is    "\("              aka $($ ;
sugar      t_parf           is    "\)"              aka $)$ ;
sugar      t_is             is    "is"              aka $is$ ;
sugar      t_end            is    "end"             aka $end$ ;
sugar      t_when           is    "when"            aka $when$ ;
sugar      t_error          is    "error"           aka $error$ ;
sugar      t_attention      is    "warning"         aka $warning$ ;
sugar      t_write          is    "write"           aka $write$ ;
sugar      t_new            is    "new"             aka $new$ ;
sugar      t_instanceof     is    "instanceof"      aka $instanceof$ ;
sugar      t_plus           is    "\+"              aka $+$ ;
sugar      t_moins          is    "\-"              aka $-$ ;
sugar      t_mult           is    "\*"              aka $*$ ;
sugar      t_div            is    "\/"              aka $/$ ;
sugar      t_d_plus         is    "\+\."            aka $+.$ ;
sugar      t_d_moins        is    "\-\."            aka $-.$ ;
sugar      t_d_mult         is    "\*\."            aka $*.$ ;
sugar      t_d_div          is    "\/\."            aka $/.$ ;
sugar      t_et             is    "(\&|(\&\&))"     aka $&$, $&&$ ;
sugar      t_ou             is    "(\||(\|\|))"     aka $|$ ,$||$ ;
sugar      t_not            is    "(\~|\!)"         aka $~$ ,$!$ ;
sugar      t_append         is    "\@"              aka $@$ ;
sugar      t_aco            is    "\{"              aka ${$ ;
sugar      t_acf            is    "\}"              aka $}$ ;
sugar      t_if             is    "if"              aka $if$ ;
sugar      t_elseif         is    "elseif"          aka $elseif$ ;
sugar      t_else           is    "else"            aka $else$ ;
sugar      t_match          is    "match"           aka $match$ ;
sugar      t_case           is    "case"            aka $case$ ;
sugar      t_default        is    "default"         aka $default$ ;
sugar      t_egal           is    "(=)"             aka $=$ ;
sugar      t_different      is    "((\/=)|(\!=))"   aka $/=$,$!=$ ;
sugar      t_nil            is    "((nil)|(null))"  aka $nil$,$null$ ;
sugar      t_true           is    "true"            aka $true$ ;
sugar      t_false          is    "false"           aka $false$ ;
--sugar      t_chaine   is    "\""                  ;
sugar      t_cro            is    "\["              aka $[$ ;
sugar      t_crf            is    "\]"              aka $]$ ;
sugar      t_string         is    "STRING"          aka $STRING$ ;
sugar      t_integer        is    "INTEGER"         aka $INTEGER$ ;
sugar      t_double         is    "DOUBLE"          aka $DOUBLE$ ;
sugar      t_char           is    "CHARACTER"       aka $CHARACTER$ ;
sugar      t_exception      is    "exception"       aka $exception$ ;
term       t_entier         is    "[0-9]+" ;
term       t_flottant       is    "[0-9]*\.[0-9]+(e[\+\-]?[0-9]+)?" ;

-- chars
macro    hex        is    "[0-9a-fA-F]" ;
macro    uni        is    "\\u{hex}{hex}{hex}{hex}" ;
macro    oct        is    "\\[0-3][0-7][0-7]" ;
-- je laisse %N et %N pour la compatibilité,
-- le visiteur java les remplace par \n et \t
macro    esc        is    "({uni}|{oct}|\\[nrtfb]|\%[NT])" ;
macro    scar       is    "[^\\\"]" ;
term     t_chaine   is    "\"({esc}|\\[\\\"]|{scar})*\"" ;

macro    ccar       is    "[^\\\']" ;
term     t_car      is    "\'({esc}|\\[\\\']|{ccar})\'" ;
term     t_ident    is    "[a-zA-Z_][a-zA-Z_0-9]*" ;


LACTION -> #res t_aco INSTS EXCEPTION t_acf #gen ;
global
  offset : INTEGER;
  length : INTEGER;

#res {
local
  t : TDS_ACTION;
do
  offset := LACTION^scanner.getOffset();
  LACTION^avis.resetIndent();
  LACTION^avis.incIndent();

  t := LACTION^act.getTds();
  INSTS^tds_act := new TDS_ACTION(t);
  EXCEPTION^tds_act := new TDS_ACTION(t);
end
}

#gen {
local
  c : STRING;
do
  -- met à jour le code de l'action
  LACTION^code := LACTION^avis.insts() @ INSTS^code @ EXCEPTION^code;
  LACTION^avis.decIndent();
  length := LACTION^scanner.getOffset() + LACTION^scanner.getLength() - offset;
  LACTION^offset := offset;
  LACTION^length := length;
end
}

TYPE -> t_ident TGEN #gen ;
#gen {
do
  TYPE^type := TYPE^res.getType(t_ident^txt, TGEN^pars);
end
}

TGEN -> #gen ;
#gen {
do
  TGEN^pars := null;
end
}

TGEN -> t_inf TYPE XTYPE t_sup #gen ;
#gen {
do
  XTYPE^pars.insertElementAt(TYPE^type, 0);
  TGEN^pars := XTYPE^pars;
end
}

XTYPE -> t_virgule TYPE XTYPE #add ;
#add {
do
  XTYPE1^pars.insertElementAt(TYPE^type, 0);
  XTYPE^pars := XTYPE1^pars;
end
}

XTYPE -> #gen;
#gen {
do
  XTYPE^pars := new Vector<IType>();
end
}

TYPE -> t_integer #gen ;
#gen { do TYPE^type := TYPE^res.getType("INTEGER"); end }

TYPE -> t_double #gen ;
#gen { do TYPE^type := TYPE^res.getType("DOUBLE"); end }

TYPE -> t_string #gen ;
#gen { do TYPE^type := TYPE^res.getType("STRING"); end }

TYPE -> t_char #gen ;
#gen { do TYPE^type := TYPE^res.getType("CHARACTER"); end }

INSTS -> #gen ;
#gen {
do
  INSTS^code := "";
end
}

INSTS -> INST INSTS #gen ;
#gen {
do
  INSTS^code := INSTS^avis.indent() @ INST^code @ "%N" @ INSTS1^code;
end
}

EXCEPTION -> #gen ;
#gen {
do
  EXCEPTION^code := "";
end
}


EXCEPTION -> t_exception t_ident #add INSTS #gen ;
global
  v : VAR;

#add {
local
  t : TDS_ACTION;
  e : ENTREE;
do
  t := EXCEPTION^tds_act;
  e := t.chercher(t_ident^txt);

  if e /= null then
    error(LACTION_local_yet_declared, t_ident^txt);
  else
    v := new VAR(t_ident^txt, null);
    t.ajouter_locale(v);
    v.setEtat(true);
  end
end
}

#gen {
do
  EXCEPTION^code := EXCEPTION^avis.exc(t_ident^txt, INSTS^code);
end
}

INST -> #trans TYPE t_ident #hgen AFF t_pointvirgule #gen ;
global
  r : Resolveur;

#trans {
do
  r := INST^act.getResolveur();
  TYPE^res := r;
end
}

#hgen {
local
  v : VAR;
  t : TDS_ACTION;
  e : ENTREE;
do
  t := INST^tds_act;
  e := t.chercher(t_ident^txt);
  if e /= null then
    error(LACTION_local_yet_declared, t_ident^txt);
  else
    v := new VAR(t_ident^txt, TYPE^type);
    AFF^hentree := v;
    t.ajouter_locale(v);

    -- inférence de type
    r.contDecl(v);
  end
end
}

#gen {
local
  t : TDS_ACTION;
  e : ENTREE;
do
  t := INST^tds_act;
  e := t.chercher(t_ident^txt);
  INST^code := INST^avis.decl(e) @ AFF^code;
end
}


AFF -> #gen ;
#gen {
do
  AFF^code := "";
end
}

AFF -> t_affectation EXPR #gen ;
#gen {
local
  r : Resolveur;
do
  if ~AFF^hentree.affectable(AFF^act.getPos()) then
     error(LACTION_var_illegal_access, AFF^hentree.getNom());
  else
    AFF^hentree.setEtat(true);

    -- expr est un triplet (nom, type, val)
    AFF^code := "%N" @ AFF^avis.indent() @ AFF^avis.aff(AFF^hentree, EXPR^code);

    -- inférence
    r := AFF^act.getResolveur();
    r.contAff(AFF^hentree, EXPR^type);
  end
end
}

INST -> VAR #trans INST2 t_pointvirgule #gen ;
#trans {
do
  INST2^hentree := VAR^entree;
end
}

#gen {
do
  INST^code := INST2^code;
end
}

INST2 -> t_affectation EXPR #gen ;
#gen {
local
  r : Resolveur;
do
  if ~INST2^hentree.affectable(INST2^act.getPos()) then
     error(LACTION_var_illegal_access, INST2^hentree.getNom());
  else
    INST2^hentree.setEtat(true);

    -- expr est un triplet (nom, type, val)
    INST2^code := INST2^avis.aff(INST2^hentree, EXPR^code);

    -- inférence
    r := INST2^act.getResolveur();
    r.contAff(INST2^hentree, EXPR^type);
  end
end
}

INST2 -> t_point t_ident #trans t_paro ARGS t_parf #hgen APP #gen ;
#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  a := new Vector<STRING>();
  ARGS^hargs := a;

  ts := new Vector<IType>();
  ARGS^htypes := ts;
end
}

#hgen {
local
  r : Resolveur;
  c : STRING;
do
  r := INST2^act.getResolveur();
  APP^htype := r.contFct(INST2^hentree.getType(), t_ident^txt, ARGS^types);
  c := INST2^avis.var(INST2^hentree);
  APP^hcode := INST2^avis.fct(c, t_ident^txt, ARGS^args);
end
}

#gen {
do
  INST2^code := APP^code + ";";
end
}

INST -> t_new #trans VAR t_point t_ident t_paro ARGS t_parf t_pointvirgule #gen ;
#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  a := new Vector<STRING>();
  ARGS^hargs := a;

  ts := new Vector<IType>();
  ARGS^htypes := ts;
end
}

#gen {
local
  r : Resolveur;
do
  if ~VAR^entree.affectable(INST^act.getPos()) then
     error(LACTION_var_illegal_access, VAR^entree.getNom());
  else
    VAR^entree.setEtat(true);
    INST^code := INST^avis.nouveau(VAR^entree, ARGS^args);
    r := INST^act.getResolveur();
    r.contProc(VAR^entree.getType(), t_ident^txt, ARGS^types);
  end
end
}

INST -> t_write t_paro EXPR t_parf t_pointvirgule #gen ;
#gen {
do
  INST^code := INST^avis.ecrire(EXPR^code);
end
}


INST -> t_error t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen ;
#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  -- les arguments
  a := new Vector<STRING>();
  EARGS^hargs := a;

  ts := new Vector<IType>();
  EARGS^htypes := ts;
end
}

#gen {
local
  r : Resolveur;
do
  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code := INST^avis.fatal(t_ident^txt, EARGS^args);
  r := INST^act.getResolveur();
  r.contErr(EARGS^types);
end
}


INST -> t_attention t_paro t_ident #trans EARGS t_parf t_pointvirgule #gen ;
#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  a := new Vector<STRING>();
  EARGS^hargs := a;
  ts := new Vector<IType>();
  EARGS^htypes := ts;
end
}

#gen {
local
  r : Resolveur;
do
  INST^table.addProperty(t_ident^txt, EARGS^args.size());
  INST^code := INST^avis.signaler(t_ident^txt, EARGS^args);
  r := INST^act.getResolveur();
  r.contErr(EARGS^types);
end
}


EARGS -> #gen ;
#gen {
do
  EARGS^args := EARGS^hargs;
  EARGS^types := EARGS^htypes;
end
}


EARGS -> t_virgule EXPR #add EARGS #gen ;
#add {
do
  EARGS^hargs.add(EXPR^code);
  EARGS^htypes.add(EXPR^type);
  EARGS1^htypes := EARGS^htypes;
end
}

#gen {
do
  EARGS^args := EARGS1^args;
  EARGS^types := EARGS1^types;
end
}

INST -> t_if t_paro EXPR t_parf t_aco #inc INSTS t_acf #dec ELSIF #gen ;
#inc {
do
  INST^avis.incIndent();
  INSTS^tds_act := new TDS_ACTION(INST^tds_act);
end
}

#dec {
do
  INST^avis.decIndent();
end
}

#gen {
local
  a: STRING;
  b: STRING;
do
  a := INSTS^code;
  b := ELSIF^code;
  INST^code := INST^avis.ifExpr(EXPR^code, a, b);
end
}

ELSIF -> t_elseif t_paro EXPR t_parf t_aco #inc INSTS t_acf #dec ELSIF #gen ;
#inc {
do
  ELSIF^avis.incIndent();
  INSTS^tds_act := new TDS_ACTION(ELSIF^tds_act);
end
}

#dec {
do
  ELSIF^avis.decIndent();
end
}

#gen {
local
  a: STRING;
  b: STRING;
do
  a := INSTS^code;
  b := ELSIF1^code;
  ELSIF^code := ELSIF^avis.indent() @ ELSIF^avis.ifSinonSi(EXPR^code, a, b);
end
}

ELSIF -> t_else t_aco #inc INSTS t_acf #gen ;
#inc {
do
  ELSIF^avis.incIndent();
  INSTS^tds_act := new TDS_ACTION(ELSIF^tds_act);
end
}

#gen {
local
  a: STRING;
do
  a := INSTS^code;
  ELSIF^avis.decIndent();
  ELSIF^code := ELSIF^avis.indent() @ ELSIF^avis.ifSinon(a) @
                ELSIF^avis.indent() @ ELSIF^avis.ifFin();
end
}

ELSIF -> #gen ;
#gen {
do
  ELSIF^code := ELSIF^avis.indent() @ ELSIF^avis.ifFin();
end
}

VAR -> t_ident #gen ;
#gen {
local
  t : TDS_ACTION;
  e : ENTREE;
  r : Resolveur;
do
  t := VAR^tds_act;
  e := t.chercher(t_ident^txt);

  if e = null then
    error(LACTION_not_a_var, t_ident^txt);
  else
    VAR^entree := e;
  end
end
}

VAR -> t_ident t_chapeau t_ident #gen ;
#gen {
local
  t : TDS_ACTION;
  e : ENTREE;
  s: STRING;
  symb : SYMBOLE;
  r : Resolveur;
do
  t := VAR^tds_act;
  s := t_ident^txt @ "^" @ t_ident1^txt;
  e := t.chercher(s);

  if e = null then
    error(LACTION_not_an_attribute, t_ident1^txt,t_ident^txt);
  else
    VAR^entree := e;
  end
end
}

INST -> t_match t_paro VAR t_parf #check t_aco CASE CASES t_acf #gen ;
#check {
do
  if ~VAR^entree.getEtat() then
    error(LACTION_var_non_initialized, VAR^entree.getNom());
  elseif ~VAR^entree.utilisable(INST^act.getPos()) then
    error(LACTION_var_illegal_access, VAR^entree.getNom());
  end

  CASE^hentree := VAR^entree;
  CASES^hentree := VAR^entree;
end
}

#gen {
do
  INST^code :=
    INST^avis.matchVarAvec(VAR^entree, CASE^type, CASE^code, CASES^code) @
    INST^avis.indent() @
    INST^avis.matchSi(VAR^entree, CASE^type, CASE^code, CASES^code);
end
}

CASE  -> t_case #res TYPE #trans t_aco INSTS t_acf #gen ;
#res {
local
  r : Resolveur;
do
  r := CASE^act.getResolveur();
  TYPE^res := r;
end
}

#trans {
do
  CASE^avis.incIndent();

  -- on transtype la variable du match
  -- pendant le temps de INSTS
  --CASE^hentree.setTypeReel(TYPE^type);
  CASE^avis.transtyper(CASE^hentree, TYPE^type);

  INSTS^tds_act := new TDS_ACTION(CASE^tds_act);
end
}

#gen {
do
  CASE^type := TYPE^type;
  CASE^nom := TYPE^type.getNom();
  CASE^code := INSTS^code;
  CASE^avis.decIndent();

  -- on retablit le type original
  --CASE^hentree.resetTypeReel();
  CASE^avis.detranstyper(CASE^hentree);
end
}

CASES -> CASE CASES #gen ;
#gen {
do
  CASES^code := CASES^avis.indent() @
                CASES^avis.matchSinonSi(CASES^hentree, CASE^type, CASE^code, CASES1^code);
end
}

CASES -> t_default #inc t_aco INSTS t_acf #gen ;
#inc {
do
  CASES^avis.incIndent();
  INSTS^tds_act := new TDS_ACTION(CASES^tds_act);
end
}

#gen {
local
  a : STRING;
do
  a := INSTS^code;
  CASES^avis.decIndent();
  CASES^code :=  CASES^avis.indent() @ CASES^avis.matchSinon(a) @
                 CASES^avis.indent() @ CASES^avis.matchFin();
end
}

CASES -> #gen ;
#gen {
do
  CASES^code := CASES^avis.indent() @ CASES^avis.matchFin();
end
}

----------------------------------
-- EXPR -> REL {and,or} REL
----------------------------------

EXPR -> REL #code EXPRREL #gen ;
#code {
do
  EXPRREL^hcode := REL^code;
  EXPRREL^htype := REL^type;
end
}

#gen {
do
  EXPR^type := EXPRREL^type;
  EXPR^code := EXPRREL^code;
end
}

EXPRREL -> OPBOOL REL #code EXPRREL #gen ;
#code {
local
  r : Resolveur;
do
  r := EXPRREL^act.getResolveur();
  EXPRREL1^htype := r.contOp(EXPRREL^htype, OPBOOL^nom, REL^type);
  EXPRREL1^hcode := EXPRREL^avis.opBool(EXPRREL^hcode, OPBOOL^nom, REL^code);
end
}

#gen {
do
  EXPRREL^type := EXPRREL1^type;
  EXPRREL^code := EXPRREL1^code;
end
}

OPBOOL -> t_et #gen ;
#gen { do OPBOOL^nom := "and"; end }

OPBOOL -> t_ou #gen ;
#gen { do OPBOOL^nom := "or"; end }

EXPRREL -> #gen ;
#gen {
do
  EXPRREL^type := EXPRREL^htype;
  EXPRREL^code := EXPRREL^hcode;
end
}

----------------------------------
-- REL -> MEXPR {>,<,=,/=} MEXPR
----------------------------------

REL -> MEXPR #code RELMEXPR #gen ;
#code {
do
  RELMEXPR^hcode := MEXPR^code;
  RELMEXPR^htype := MEXPR^type;
end
}

#gen {
do
  REL^type := RELMEXPR^type;
  REL^code := RELMEXPR^code;
end
}

RELMEXPR -> OPCOMP MEXPR #code RELMEXPR #gen ;
#code {
local
  r : Resolveur;
do
  r := RELMEXPR^act.getResolveur();
  RELMEXPR1^htype := r.contOp(RELMEXPR^htype, OPCOMP^nom, MEXPR^type);
  RELMEXPR1^hcode := RELMEXPR^avis.opComp(RELMEXPR^hcode, OPCOMP^nom, MEXPR^code);
end
}

#gen {
do
  RELMEXPR^type := RELMEXPR1^type;
  RELMEXPR^code := RELMEXPR1^code;
end
}

OPCOMP -> t_inf #gen ;
#gen { do OPCOMP^nom := "<"; end }

OPCOMP -> t_inf_egal #gen ;
#gen { do OPCOMP^nom := "<="; end }

OPCOMP -> t_sup #gen ;
#gen { do OPCOMP^nom := ">"; end }

OPCOMP -> t_sup_egal #gen ;
#gen { do OPCOMP^nom := ">="; end }

OPCOMP -> t_egal #gen ;
#gen { do OPCOMP^nom := "="; end }

OPCOMP -> t_different #gen ;
#gen { do OPCOMP^nom := "/="; end }

RELMEXPR -> #gen ;
#gen {
do
  RELMEXPR^type := RELMEXPR^htype;
  RELMEXPR^code := RELMEXPR^hcode;
end
}

----------------------------------
-- MEXPR -> TERME {+,-} TERME
----------------------------------

MEXPR -> TERME #code MEXPRTERME #gen ;
#code {
do
  MEXPRTERME^hcode := TERME^code;
  MEXPRTERME^htype := TERME^type;
end
}

#gen {
do
  MEXPR^type := MEXPRTERME^type;
  MEXPR^code := MEXPRTERME^code;
end
}

MEXPRTERME -> OPADD TERME #code MEXPRTERME #gen ;
#code {
local
  r : Resolveur;
do
  r := MEXPRTERME^act.getResolveur();
  MEXPRTERME1^htype := r.contOp(MEXPRTERME^htype, OPADD^nom, TERME^type);
  MEXPRTERME1^hcode := MEXPRTERME^avis.opAdd(MEXPRTERME^hcode, OPADD^nom, TERME^code);
end
}

#gen {
do
  MEXPRTERME^type := MEXPRTERME1^type;
  MEXPRTERME^code := MEXPRTERME1^code;
end
}

OPADD -> t_append #gen ;
#gen { do OPADD^nom := "@"; end }

OPADD -> t_plus #gen ;
#gen { do OPADD^nom := "+"; end }

OPADD -> t_moins #gen ;
#gen { do OPADD^nom := "-"; end }

OPADD -> t_d_plus #gen ;
#gen { do OPADD^nom := "+."; end }

OPADD -> t_d_moins #gen ;
#gen { do OPADD^nom := "-."; end }

MEXPRTERME -> #gen ;
#gen {
do
  MEXPRTERME^type := MEXPRTERME^htype;
  MEXPRTERME^code := MEXPRTERME^hcode;
end
}

----------------------------------
-- TERME -> FACTEUR {*,/} FACTEUR
----------------------------------

TERME -> FACTEUR #code TERMEFACTEUR #gen ;
#code {
do
  TERMEFACTEUR^htype := FACTEUR^type;
  TERMEFACTEUR^hcode := FACTEUR^code;
end
}

#gen {
do
  TERME^type := TERMEFACTEUR^type;
  TERME^code := TERMEFACTEUR^code;
end
}

FACTEUR -> t_nil #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("VOID");
  FACTEUR^code := FACTEUR^avis.vide();
end
}


FACTEUR -> t_true #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("BOOLEAN");
  FACTEUR^code := FACTEUR^avis.vrai();
end
}


FACTEUR -> t_false #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("BOOLEAN");
  FACTEUR^code := FACTEUR^avis.faux();
end
}


FACTEUR -> t_entier #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("INTEGER");
  FACTEUR^code := FACTEUR^avis.entier(t_entier^txt);
end
}


FACTEUR -> t_moins FACTEUR #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("INTEGER");
  FACTEUR^code := FACTEUR^avis.moins(FACTEUR1^code);
end
}


FACTEUR -> t_flottant #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("DOUBLE");
  FACTEUR^code := FACTEUR^avis.reel(t_flottant^txt);
end
}


FACTEUR -> t_car #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("CHARACTER");
  FACTEUR^code := FACTEUR^avis.car(t_car^txt);
end
}


FACTEUR -> t_chaine #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.getType("STRING");
  FACTEUR^code := FACTEUR^avis.chaine(t_chaine^txt);
end
}


FACTEUR -> VAR #check APP #gen ;
#check {
do
  if ~VAR^entree.getEtat() then
    error(LACTION_var_non_initialized, VAR^entree.getNom());
  elseif ~VAR^entree.utilisable(FACTEUR^act.getPos()) then
    error(LACTION_var_illegal_access, VAR^entree.getNom());
  else
    APP^htype := VAR^entree.getType();
    APP^hcode := FACTEUR^avis.var(VAR^entree);
  end
end
}

#gen {
do
  FACTEUR^type := APP^type;
  FACTEUR^code := APP^code;
end
}

APP -> #gen ;
#gen {
do
  APP^type := APP^htype;
  APP^code := APP^hcode;
end
}

APP -> t_point t_ident #trans t_paro ARGS t_parf #hgen APP #gen ;
#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  a := new Vector<STRING>();
  ARGS^hargs := a;

  ts := new Vector<IType>();
  ARGS^htypes := ts;
end
}

#hgen {
local
  r: Resolveur;
do
  r := APP^act.getResolveur();
  APP1^htype := r.contFct(APP^htype, t_ident^txt, ARGS^types);
  APP1^hcode := APP^avis.fct(APP^hcode, t_ident^txt, ARGS^args);
end
}

#gen {
do
  APP^type := APP1^type;
  APP^code := APP1^code;
end
}

FACTEUR -> t_not FACTEUR #gen ;
#gen {
local
  r : Resolveur;
do
  r := FACTEUR^act.getResolveur();
  FACTEUR^type := r.contOpNon(FACTEUR1^type);
  FACTEUR^code := FACTEUR^avis.non(FACTEUR1^code);
end
}

FACTEUR -> t_paro EXPR t_parf #gen ;
#gen {
do
  FACTEUR^type := EXPR^type;
  FACTEUR^code := "(" + EXPR^code + ")";
end
}

FACTEUR -> t_new #trans TYPE t_paro ARGS t_parf #gen ;
global
  r: Resolveur;

#trans {
local
  a : Vector<STRING>;
  ts : Vector<IType>;
do
  r := FACTEUR^act.getResolveur();
  TYPE^res := r;
  a := new Vector<STRING>();
  ARGS^hargs := a;
  ts := new Vector<IType>();
  ARGS^htypes := ts;
end
}

#gen {
do
  FACTEUR^code := FACTEUR^avis.nouveau(TYPE^type, ARGS^args);
  FACTEUR^type := r.contConst(TYPE^type, ARGS^types);
end
}

FACTEUR -> t_instanceof t_paro EXPR t_virgule #trans TYPE t_parf #gen ;
global
  r: Resolveur;

#trans {
do
  r := FACTEUR^act.getResolveur();
  TYPE^res := r;
end
}

#gen {
do
  FACTEUR^type := r.getType("BOOLEAN");
  FACTEUR^code := FACTEUR^avis.instanceOf(EXPR^code, TYPE^type);
end
}

TERMEFACTEUR -> OPMUL FACTEUR #code TERMEFACTEUR #gen ;
#code {
local
  r : Resolveur;
do
  r := TERMEFACTEUR^act.getResolveur();
  TERMEFACTEUR1^htype := r.contOp(TERMEFACTEUR^htype, OPMUL^nom, FACTEUR^type);
  TERMEFACTEUR1^hcode := TERMEFACTEUR^avis.opMul(TERMEFACTEUR^hcode, OPMUL^nom, FACTEUR^code);
end
}

#gen {
do
  TERMEFACTEUR^type := TERMEFACTEUR1^type;
  TERMEFACTEUR^code := TERMEFACTEUR1^code;
end
}

OPMUL -> t_mult #gen ;
#gen { do OPMUL^nom := "*"; end }

OPMUL -> t_div #gen ;
#gen { do OPMUL^nom := "/"; end }

OPMUL -> t_d_mult #gen ;
#gen { do OPMUL^nom := "*."; end }

OPMUL -> t_d_div #gen ;
#gen { do OPMUL^nom := "/."; end }

TERMEFACTEUR -> #gen ;
#gen {
do
  TERMEFACTEUR^type := TERMEFACTEUR^htype;
  TERMEFACTEUR^code := TERMEFACTEUR^hcode;
end
}


ARGS -> #gen ;
#gen {
do
  ARGS^args := ARGS^hargs;
  ARGS^types := ARGS^htypes;
end
}


ARGS -> EXPR #expr ARGSX #gen ;
#expr {
do
  ARGS^hargs.add(EXPR^code);
  ARGS^htypes.add(EXPR^type);
  ARGSX^htypes := ARGS^htypes;
end
}

#gen {
do
  ARGS^args := ARGSX^args;
  ARGS^types := ARGSX^types;
end
}

ARGSX -> #gen ;
#gen {
do
  ARGSX^args := ARGSX^hargs;
  ARGSX^types := ARGSX^htypes;
end
}


ARGSX -> t_virgule EXPR #expr ARGSX #gen ;
#expr {
do
  ARGSX^hargs.add(EXPR^code);
  ARGSX^htypes.add(EXPR^type);
  ARGSX1^htypes := ARGSX^htypes;
end
}

#gen {
do
  ARGSX^args := ARGSX1^args;
  ARGSX^types := ARGSX1^types;
end
}

end
